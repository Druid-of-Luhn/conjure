{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}

module Stuff.Generic.Definition where

import Control.Monad.Error ( throwError )
import Data.Map ( Map, fromList )
import Data.Generics ( Data, Typeable )
import Text.PrettyPrint ( text, comma, punctuate, sep, vcat )
import Data.Proxy ( Proxy(..) )
import Data.List.Split ( splitOn )
import Data.Maybe ( mapMaybe, listToMaybe )

import Stuff.TryMatch
import Stuff.Pretty

import Language.Haskell.TH
import Language.Haskell.TH.Quote
import Language.Haskell.Meta.Parse.Careful
import Language.Haskell.TH.Lift ( deriveLift )


data Generic tag primitive proxy
    = Prim primitive
    | Tagged !Int (Proxy tag) [Generic tag primitive proxy]
    deriving (Eq, Ord, Read, Show, Data, Typeable)

tagged :: Enum tag => tag -> [Generic tag primitive proxy] -> Generic tag primitive proxy
tagged tag xs = Tagged (fromEnum tag) Proxy xs

viewTagged :: [Int] -> Generic tag primitive proxy -> Maybe [Generic tag primitive proxy]
viewTagged [] g = Just [g]
viewTagged (t:ts) (Tagged i _ xs) | t == i = Just $ concat $ mapMaybe (viewTagged ts) xs
viewTagged _ _ = Nothing


genView :: Pat -> [Int] -> Q Pat
genView pat ts = do
    x     <- [e| viewTagged ts |]
    return $ ViewP x pat

match :: QuasiQuoter
match = QuasiQuoter {
    quotePat = \ inp -> do
        let inps = splitOn "|" inp
        let each i = do
                let [patternS, tag] = splitOn ":=" i
                let tags = map read $ splitOn "." tag
                case parsePat ("Just (" ++ patternS ++ ")") of
                    Left  e -> error e
                    Right p -> genView p tags
        pats <- mapM each inps
        return $ TupP pats
    , quoteExp  = undefined
    , quoteType = undefined
    , quoteDec  = undefined
    }

-- data GenericPat
--     = GenericPat Pat [String]

-- data GenericPat
--     = MetaVar String
--     | NamedPat String GenericPat
--     | ListPat [GenericPat]
--     | ObjectPat [(String,GenericPat)]
--     deriving (Eq, Ord, Read, Show, Data, Typeable)
-- 
-- deriveLift ''GenericPat
-- 
-- instance (Pretty tag, Pretty primitive) => Pretty (Generic tag primitive proxy) where
--     pretty (Prim  p  ) = pretty p
--     pretty (Named t v) = pretty t <> ":" <+> pretty v
--     pretty (List  xs ) = sep $ ["["]
--                             ++ punctuate comma (map pretty xs)
--                             ++ ["]"]
--     pretty (Object m ) = sep $ ["{"]
--                             ++ punctuate comma (map (\ (t,v) -> pretty t <> ":" <+> pretty v ) m)
--                             ++ ["}"]
-- 
-- instance Pretty GenericPat where
--     pretty (NamedPat t v) = pretty t <> ":" <+> pretty v
--     pretty (ListPat  xs ) = sep $ ["["]
--                                ++ punctuate comma (map pretty xs)
--                                ++ ["]"]
--     pretty (ObjectPat m ) = sep $ ["{"]
--                                ++ punctuate comma (map (\ (t,v) -> pretty t <> ":" <+> pretty v ) m)
--                                ++ ["}"]
